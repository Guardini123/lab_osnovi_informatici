/**
 * dict.c -- программа чтения словаря и печати словарных статей по маске
 *
 * Copyright (c) 2009, Guardini123 <betelev@cs.karelia.ru>
 *
 * This code is licensed under a MIT-style license.
 */

#include <stdio.h> /* заголовочный_файл-библиотека для ввода-вывода */
#include <stdlib.h> /* ... (что-то) */
#include <string.h> /* заголовочный_файл-библиотека для простой работы со строк                                                                                                             $
#include <ctype.h> /* ... (что-то номер 2) */

#define MAXLINE 1024 /* максимальная длинна строки */
#define TRUE 1 /* потому что хочу */
#define FALSE 0 /* потому что могу */
/* просто в коде программы заменяю 1 на TRUE, а 0 на FALSE */

void detecting_lines(FILE* file);

int main(int argc, char*argv[])
{
    FILE* dict = NULL;  /* Файл словаря */

    if (argc != 2)  /* Если кол-во аргументов не совпадает с нужным... */
    {
        fprintf(stderr ,"Колличество аргументов либо меньше либо больше двух!\n");                                                                                                      $
        exit(EXIT_FAILURE);  /* ...выйти из программы с ошибкой. */
    }

    dict = fopen(argv[1], "r");  /* Открываем файл словаря */

    if (dict == NULL)  /* Если не удалось открыть файл словаря... */
    {
        fprintf(stderr, "Файл не найден или не может быть прочитан!\n");
        exit(EXIT_FAILURE);  /* ...выйти из программы с ошибкой. */
    }

    detecting_lines(dict);

    fclose(dict);  /* Завершаем работу с файлом словаря */

    return 0;  /*оповещаем о том, что программа успешно завершила свою работу*/
}

void detecting_lines (FILE* file)
{
    int flag = FALSE;  /* Типа bool для определения надо ли нам выводить текущую строчку. В течении программы принимает значения только 0 (FALSE) или 1 (TRUE) */

    int i;  /* порядковый номер текущего символа маски */

    int j;  /* порядковый номер текущего символа строки */

    int c;  /* Длинна введённой маски. */
        /* Из-за того, что стандарт C89 запрещает программисту сладко жить, придётся объявить эту переменную здесь. А могли бы вообще не объявлять */

    char current_line[MAXLINE];  /* Текущая строка словаря */

    char mask[MAXLINE];  /* Введённая маска, по которой будем искать слово */

    scanf("%s", mask);  /* Вводим строку маски, по которой будем искать слово */

    c = strlen(mask);  /* Не забываем о нашей переменной "c" */

    while (fgets(current_line, MAXLINE, file) != NULL)   /* Просматриваем словарь, печатая строки запрошенной статьи */
    {
        if(!isspace(current_line[0]))  /* Текущая строка начинается с пробела? */
        {
            flag = FALSE;  /* Работает? НЕ ТРОГАЙ!!! */
            j = 0;  /* порядковый номер текущего символа строки */
            if(current_line[0] == '-')  /* текущая строка начинается с тире? */
            {
                j++;  /* начнём обзор строки со следующего символа. Надеемся, это будет буква */
            }
            for (i = 0; i < c; i++)  /* Идём по маске и смотрим каждый символ */
            {
                if (mask[i] == current_line[j])  /* Если текущий символ совпадает с символом текущей строки ... */
                {
                    flag = TRUE;
                    j++;  /* ...перейдём к следующей паре символов */
                } else {  /* если нет... */
                    flag = FALSE;
                    break;  /* ...нас эта строка больше не интересует, flag стал равен 0 (FALSE) и следующий за for if не сработает */
                }
            }
        }
        if (flag == TRUE)  /* Если мы должны вывести эту строку (Если по окончании предыдущего цикла flag всё же остался равен 1 (TRUE) ) , то... */
        {
            printf("%s", current_line);  /* Ввыводим её?! */
        }
    }

}
